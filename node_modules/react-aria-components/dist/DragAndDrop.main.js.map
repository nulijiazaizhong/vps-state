{"mappings":";;;;;;;;;;;;;;;;AAAA;;;;;;;;;;CAUC;AAaM,MAAM,0DAAqB,CAAA,GAAA,0BAAY,EAA2B,CAAC;AACnE,MAAM,0DAAuB,CAAA,GAAA,0BAAY,EAAoC;AAkB7E,MAAM,0DAAgB,CAAA,GAAA,uBAAS,EAAE,SAAS,cAAc,KAAyB,EAAE,GAA8B;IACtH,IAAI,UAAC,MAAM,EAAC,GAAG,CAAA,GAAA,uBAAS,EAAE;IAC1B,qBAAO,sHAAG,OAAO,OAAO;AAC1B;AAIO,SAAS,0CAAuB,gBAAmC,EAAE,SAAoC;QAEtF;IADxB,IAAI,sBAAsB,6BAAA,uCAAA,iBAAkB,mBAAmB;IAC/D,IAAI,oBAAoB,6BAAA,wCAAA,sCAAA,iBAAkB,iBAAiB,cAAnC,0DAAA,yCAAA;IACxB,IAAI,KAAK,CAAA,GAAA,wBAAU,EAAE,CAAC;QACpB,sFAAsF;QACtF,IAAI,sBAAqB,sBAAA,gCAAA,UAAW,YAAY,CAAC,UAC/C,OAAO,sBAAsB,oBAAoB,wBAAU,0DAAC;YAAc,QAAQ;;IAEpF,6CAA6C;IAC7C,uDAAuD;IACzD,GAAG;QAAC,sBAAA,gCAAA,UAAW,MAAM;QAAE;QAAmB;KAAoB;IAC9D,OAAO,CAAA,6BAAA,uCAAA,iBAAkB,gBAAgB,IAAG,KAAK;AACnD;AAEO,SAAS,yCAAoB,gBAA0C,EAAE,gBAAmC,EAAE,SAAoC;QAInJ,qCAA2C;IAH/C,mDAAmD;IACnD,IAAI,aAAa,iBAAiB,UAAU;IAC5C,IAAI,gBAAwC;IAC5C,IAAI,CAAA,6BAAA,wCAAA,sCAAA,iBAAkB,iBAAiB,cAAnC,0DAAA,yCAAA,sBAA2C,CAAA,sBAAA,iCAAA,oBAAA,UAAW,MAAM,cAAjB,wCAAA,kBAAmB,IAAI,MAAK,QAAQ;QACjF,gBAAgB,UAAU,MAAM,CAAC,GAAG;QACpC,IAAI,UAAU,MAAM,CAAC,YAAY,KAAK,SAAS;YAC7C,iFAAiF;YACjF,IAAI,UAAU,UAAU,UAAU,CAAC,WAAW,CAAC;YAC/C,IAAI,oBAAgC;YACpC,IAAI,WAAW,MAAM;oBACD;oBAAA;gBAAlB,IAAI,cAAc,CAAA,uCAAA,gCAAA,UAAU,UAAU,CAAC,OAAO,CAAC,4BAA7B,oDAAA,8BAA6C,KAAK,cAAlD,iDAAA,sCAAsD;gBACxE,wGAAwG;gBACxG,MAAO,QAAS;oBACd,IAAI,OAAO,UAAU,UAAU,CAAC,OAAO,CAAC;oBACxC,qCAAqC;oBACrC,IAAI,CAAC,MACH;oBAEF,6EAA6E;oBAC7E,qCAAqC;oBACrC,IAAI,KAAK,IAAI,KAAK,QAAQ;wBACxB,UAAU,UAAU,UAAU,CAAC,WAAW,CAAC;wBAC3C;oBACF;wBAIK;oBAFL,wDAAwD;oBACxD,qCAAqC;oBACrC,IAAI,AAAC,CAAA,CAAA,cAAA,KAAK,KAAK,cAAV,yBAAA,cAAc,CAAA,KAAM,aACvB;oBAGF,oBAAoB;oBACpB,UAAU,UAAU,UAAU,CAAC,WAAW,CAAC;gBAC7C;YACF;gBAGgB;YADhB,kEAAkE;YAClE,gBAAgB,CAAA,OAAA,oBAAA,qBAAA,UAAW,+BAAX,kBAAA,OAAgC;QAClD;IACF;IAEA,OAAO,CAAA,GAAA,oBAAM,EAAE;QACb,OAAO,IAAI,IAAI;YAAC;YAAY;SAAc,CAAC,MAAM,CAAC,CAAA,IAAK,KAAK;IAC9D,GAAG;QAAC;QAAY;KAAc;AAChC","sources":["packages/react-aria-components/src/DragAndDrop.tsx"],"sourcesContent":["/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport type {DropIndicatorProps as AriaDropIndicatorProps, ItemDropTarget, Key} from 'react-aria';\nimport type {DragAndDropHooks} from './useDragAndDrop';\nimport type {DraggableCollectionState, DroppableCollectionState, MultipleSelectionManager} from 'react-stately';\nimport React, {createContext, ForwardedRef, forwardRef, JSX, ReactNode, useCallback, useContext, useMemo} from 'react';\nimport type {RenderProps} from './utils';\n\nexport interface DragAndDropContextValue {\n  dragAndDropHooks?: DragAndDropHooks,\n  dragState?: DraggableCollectionState,\n  dropState?: DroppableCollectionState\n}\n\nexport const DragAndDropContext = createContext<DragAndDropContextValue>({});\nexport const DropIndicatorContext = createContext<DropIndicatorContextValue | null>(null);\n\nexport interface DropIndicatorRenderProps {\n  /**\n   * Whether the drop indicator is currently the active drop target.\n   * @selector [data-drop-target]\n   */\n  isDropTarget: boolean\n}\n\nexport interface DropIndicatorProps extends Omit<AriaDropIndicatorProps, 'activateButtonRef'>, RenderProps<DropIndicatorRenderProps> { }\ninterface DropIndicatorContextValue {\n  render: (props: DropIndicatorProps, ref: ForwardedRef<HTMLElement>) => ReactNode\n}\n\n/**\n * A DropIndicator is rendered between items in a collection to indicate where dropped data will be inserted.\n */\nexport const DropIndicator = forwardRef(function DropIndicator(props: DropIndicatorProps, ref: ForwardedRef<HTMLElement>): JSX.Element {\n  let {render} = useContext(DropIndicatorContext)!;\n  return <>{render(props, ref)}</>;\n});\n\ntype RenderDropIndicatorRetValue = ((target: ItemDropTarget) => ReactNode | undefined) | undefined\n\nexport function useRenderDropIndicator(dragAndDropHooks?: DragAndDropHooks, dropState?: DroppableCollectionState): RenderDropIndicatorRetValue {\n  let renderDropIndicator = dragAndDropHooks?.renderDropIndicator;\n  let isVirtualDragging = dragAndDropHooks?.isVirtualDragging?.();\n  let fn = useCallback((target: ItemDropTarget) => {\n    // Only show drop indicators when virtual dragging or this is the current drop target.\n    if (isVirtualDragging || dropState?.isDropTarget(target)) {\n      return renderDropIndicator ? renderDropIndicator(target) : <DropIndicator target={target} />;\n    }\n    // We invalidate whenever the target changes.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dropState?.target, isVirtualDragging, renderDropIndicator]);\n  return dragAndDropHooks?.useDropIndicator ? fn : undefined;\n}\n\nexport function useDndPersistedKeys(selectionManager: MultipleSelectionManager, dragAndDropHooks?: DragAndDropHooks, dropState?: DroppableCollectionState): Set<Key> {\n  // Persist the focused key and the drop target key.\n  let focusedKey = selectionManager.focusedKey;\n  let dropTargetKey: Key | null | undefined = null;\n  if (dragAndDropHooks?.isVirtualDragging?.() && dropState?.target?.type === 'item') {\n    dropTargetKey = dropState.target.key;\n    if (dropState.target.dropPosition === 'after') {\n      // Normalize to the \"before\" drop position since we only render those to the DOM.\n      let nextKey = dropState.collection.getKeyAfter(dropTargetKey);\n      let lastDescendantKey: Key | null = null;\n      if (nextKey != null) {\n        let targetLevel = dropState.collection.getItem(dropTargetKey)?.level ?? 0;\n        // Skip over any rows that are descendants of the target (\"after\" position should be after all children)\n        while (nextKey) {\n          let node = dropState.collection.getItem(nextKey);\n          // eslint-disable-next-line max-depth\n          if (!node) {\n            break;\n          }\n          // Skip over non-item nodes (e.g., loaders) since they can't be drop targets.\n          // eslint-disable-next-line max-depth\n          if (node.type !== 'item') {\n            nextKey = dropState.collection.getKeyAfter(nextKey);\n            continue;\n          }\n\n          // Stop once we find an item at the same level or higher\n          // eslint-disable-next-line max-depth\n          if ((node.level ?? 0) <= targetLevel) {\n            break;\n          }\n          \n          lastDescendantKey = nextKey;\n          nextKey = dropState.collection.getKeyAfter(nextKey);\n        }\n      }\n\n      // If nextKey is null (end of collection), use the last descendant\n      dropTargetKey = nextKey ?? lastDescendantKey ?? dropTargetKey;\n    }\n  }\n\n  return useMemo(() => {\n    return new Set([focusedKey, dropTargetKey].filter(k => k != null));\n  }, [focusedKey, dropTargetKey]);\n}\n"],"names":[],"version":3,"file":"DragAndDrop.main.js.map"}